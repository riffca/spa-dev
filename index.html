<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
</head>
<body>

	<div
		data-text="Hohu"
		data-component="button">
	</div>


	<div
		data-text="Pizda"
		data-component="button"
		class="component-button">
	</div>


	<div 
		data-list="Pop,Up,Grate,Home,New"
		data-component="list"
		class="component-list">
	</div>

	<div 
		data-list="1,2,3,4,5"
		data-component="list"
		class="component-list">
	</div>


	<div 
		data-component="images"
		data-images="google.com,2,3,4,5,6"
		class="component-images">
	</div>


	<div id="container"></div>
	<script type="module">

		const definedComponentsAttrs = {}
		const fetchedComponents = {}
		const fetched = {}


		let observer = new MutationObserver(mutationRecords => {
			for (const mutation of mutationRecords) {
				if (mutation.type === "childList") {
					for(let index = 0; index < mutation.addedNodes.length; index++) {
						const node = mutation.addedNodes[index]
						if(node.name !== '#text' && node.getAttribute) {
			
						}	
					}
			   	}
			}
		});

		observer.observe(document.body, {
		  	childList: true, 
		  	subtree: true, 
		});


		function getInner(node){
			return [...node.querySelectorAll('[data-component]')]
		}



		async function createComponent(componentName, upgradeComponent){
			let template =fetched[componentName]

			if(!template) {
				template = await fetch(`./components/${componentName}.html`)
				.then(res=>res.text()).then((res)=>res)	
				if(template) {
					fetched[componentName] = template
				}
			}
			
			const empties = document.querySelectorAll('.component-' + componentName)
			const parser = new DOMParser();

			//dom.firstElementChild.content

			const componentDoc= parser.parseFromString(template, "text/html");
			const noResponse = template.includes('Not Found');
			//console.log(componentDoc.documentElement);

			[...empties].forEach(elTarget=>{
				const component = noResponse ? document.createElement('div') : componentDoc.documentElement.querySelector('body > :first-child')
				const values = {}

				const attrs = [].filter.call(elTarget.attributes, at => /^data-/.test(at.name));

				attrs.forEach(attribute=>{
					values[attribute.name] = {
						target: noResponse ? component : component.querySelector(`[${attribute.name}]`),
						value: attribute.value
					}
					if(!upgradeComponent) {
						const textHolder = noResponse ? component : component.querySelector(`[${attribute.name}]`)
						if(textHolder) {
							textHolder.textContent = attribute.value
						}
					}
				})

				upgradeComponent && upgradeComponent(component, values, elTarget)

				elTarget.classList.add(...component.classList)
				elTarget.replaceChildren(...component.children)

				getInner(elTarget).forEach(async item=>{
					if(item.getAttribute('data-init')) return 
					const name = item.getAttribute('data-component')
					const params = {
						name,
						node: item,
					}

					if(definedComponentsAttrs[name]){
						params.attrs = definedComponentsAttrs[name]
						console.log(definedComponentsAttrs[name])
					}	

					await setupComponent(params)
				})
			})

		}

		initApp()


		function initApp(){
			initComponent({
				name: 'list',
				attrs(key, value, target){
					if(key === 'data-list') {
						const list = value.split(',')
						const children = []
						list.forEach(item=>{
							const li = document.createElement('li')
							li.textContent = item
							children.push(li)
						})

						const ul = document.createElement('ul')
						ul.replaceChildren(...children)
						target.replaceChildren(ul)
					}
				},
			})

			initComponent({
				name: 'button',
				attrs(key, value, target){
					if(key === 'data-text') {
						const doc = target.querySelector('[data-text]')
						if(doc) {
							doc.textContent = value
						} else {
							target.textContent = value
						}
					}
				},
			})

			initComponent({
				name: 'images',
				attrs(key, value, target, wrapper){
					if(key === 'data-images') {
						const list = value.split(',')
						const children = []
						list.forEach(item=>{
							const img = document.createElement('img')
							img.setAttribute('src', item)
							children.push(img)
						})

						target.replaceChildren(...children)
					}
				}
			})

			initComponents()
		}

		function initComponents() {
			const empties = document.querySelectorAll('[data-component]');

			[...empties].forEach(async elTarget=>{
				const componentName = elTarget.getAttribute('data-component')
				const component = await getComponent(componentName)

				const inner = getInner(component)

				if(inner.length) {
					elTarget.replaceChildren(component)

					const dataAttrs = [].filter.call(elTarget.attributes, at => /^data-/.test(at.name));

					const name = elTarget.getAttribute('data-component')
					
					let attrsFunc = null
					if(definedComponentsAttrs[name]){
						attrsFunc = definedComponentsAttrs[name]
					}	

					setupComponent({ node: elTarget, attrs: attrsFunc, name })


					const components = []
					for (const item of inner) {
						if(item.getAttribute('data-init')) return 

						const name = item.getAttribute('data-component')
						const params = {
							name,
							node: item,
						}
						if(definedComponentsAttrs[name]){
							params.attrs = definedComponentsAttrs[name]
						}	

						const dataAttrs = [].filter.call(item.attributes, at => /^data-/.test(at.name));
						params.dataAttrs = dataAttrs
		
						await setupComponent(params)
					
					}
				

					//const div = createElement('div')
					//elTarget.replaceChildren(component)
				} else {
					const dataAttrs = [].filter.call(elTarget.attributes, at => /^data-/.test(at.name));

					const result = await setupComponent({
						name: componentName,
						node: elTarget,
						attrs: definedComponentsAttrs[componentName],

						dataAttrs
					})

					if(result[Symbol.iterator]) {
						elTarget.replaceChildren(...result)
					} else {
						elTarget.replaceChildren(result)
					}


				}

			})

		}

		async function getComponent(componentName){

			let path = `./components/${componentName}.html`
			let template = null

			if(fetchedComponents[path]) {
				template = fetchedComponents[path]
			}

			if(!template) {
				template = await fetch(path)
					.then(res=>res.text()).then((res)=>res)

				const noResponse = template.includes('Not Found');
				if(!noResponse && template) {
				 	fetchedComponents[path] = template
				} 

				if(noResponse) {
					template = null
				}

				fetchedComponents[path] = template

			}


			const componentDoc = template ? 
				new DOMParser().parseFromString(template, "text/html") : null



			const component = componentDoc ? 
				componentDoc.documentElement.querySelector('body > :first-child') :
				document.createElement('div') 

			return component
		}


		function hasDataAttrs(node) {
			return [].filter.call(node.attributes, at => /^data-/.test(at.name)).length;
		}

		async function setupComponent({
			name,
			attrs,
			node,
			dataAttrs
		}){
			if(!node) {
				node = await getComponent(name)
			}

			if(node.getAttribute('data-init')) return node
			node.setAttribute('data-init', true)

			const initAttributes = {}

			let initAttrs = dataAttrs || [].filter.call(node.attributes, at => /^data-/.test(at.name));
			initAttrs.forEach(item=>{
				initAttributes[item.name] = {
					target: node,
					value: item.value
				}
			})


			if(!definedComponentsAttrs[name] && attrs) {
				definedComponentsAttrs[name] = attrs
			} 

			if(!attrs) {
				attrs = definedComponentsAttrs[name]
			}

			if(!attrs) return node

			Object.keys(initAttributes).forEach(key=>{
				const { value, target } = initAttributes[key]
				if(!target) return

				attrs(key, value, target, node)
			})

			let observer = new MutationObserver(mutationRecords => {
			  	for (const mutation of mutationRecords) {
				    if (mutation.type === "attributes") {
				    	if(!mutation.attributeName.includes('data')) return 
				    	const value = mutation.target.attributes[mutation.attributeName].value
				    	value && attrs(mutation.attributeName, value, mutation.target, node)
				      	//console.log(`The ${mutation.attributeName} attribute was modified.`);
				    }
				 }
			});

			observer.observe(node, {
				attributeOldValue: true,
			  	attributes: true
			});

			return node
		}


		async function initComponent({
			name,
			attrs,
			node
		}){

			if(attrs && !definedComponentsAttrs[name]) {
				definedComponentsAttrs[name] = attrs
			} 

			// await createComponent(name, (component, attributes, elTarget)=>{
			// 	elTarget.setAttribute('data-init', true)

			// 	Object.keys(attributes).forEach(key=>{
			// 		const { value, target } = attributes[key]
			// 		if(!target) return
			// 		attrs(key, value, target, elTarget)
			// 	})

			// 	let observer = new MutationObserver(mutationRecords => {
			// 	  	console.log(name, mutationRecords)

			// 	  	for (const mutation of mutationRecords) {
			// 		    if (mutation.type === "attributes") {
			// 		    	if(!mutation.attributeName.includes('data')) return 
			// 		    	const value = mutation.target.attributes[mutation.attributeName].value
			// 		    	value && attrs(mutation.attributeName, value, mutation.target, elTarget)
			// 		      	//console.log(`The ${mutation.attributeName} attribute was modified.`);
			// 		    }
			// 		 }
			// 	});

			// 	observer.observe(elTarget, {
			// 		attributeOldValue: true,
			// 	  	attributes: true
			// 	});

			// }, node ? [node] : null)

		}

	</script>
	
</body>
</html>